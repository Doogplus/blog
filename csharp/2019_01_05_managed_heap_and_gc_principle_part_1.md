# Managed Heap & CSharp GC Principle 

本文主要是对《CLR via C#》一书中GC的总结,分上下两篇.

## 目录
- [介绍](#介绍)
- [托管堆内存分配](#托管堆内存分配)
- [GC回收过程](#GC回收过程)
- [代](#代)
- [GC的触发条件](#触发条件)
- [参考资料](#参考资料)

## 介绍
GC(Garbage Collection),主要作用是 __帮助开发者自动管理应用程序内存__.  
了解GC,好处诸多,其中之一就是代码规范,避免出现写出类似下面这种代码:  
``` csharp
            FileStream fs = null;
            StreamWriter sw = null;

            try
            {
                fs = new FileStream(Environment.CurrentDirectory + "/Test.txt", FileMode.OpenOrCreate);
                sw = new StreamWriter(fs);
            }
            catch (Exception ex)
            {

            }
            finally
            {
                if (sw != null)
                    sw.Dispose();
                if (fs != null)
                    fs.Dispose();
            }
```

## 托管堆内存分配
通常在C#中,我们使用资源需要经过以下流程:  
1. 调用IL指令newobj,为代表资源的类型分配内存
2. 设置资源的初始化状态(通过调用类型的实例构造器来完成).
3. 在实例的生命周期内访问资源(重复).
4. 摧毁资源的状态以进行清理(可选,目前未找到实例验证).
5. 释放内存.

简化之后的流程可以概述为: __分配->初始化->使用->释放__

分配的详细流程又可概括为:
1. 计算类型的字段(以及从基类型继承的字段)所需的字节数.
2. 加上实例对象所需要的额外开销(类型对象指针和同步块索引).
3. CLR检查托管堆中是否有足够的空间容纳实例对象所需要的字节数，若有，则分配，反之，则触发GC进行回收

## GC回收过程
因托管堆的内存不是无限的,所以需要GC释放内存来使程序可以使用更多的资源.在GC进行释放内存时，需要确定哪些资源是需要被释放的，
由此引入引用跟踪算法.过程如下:  
1. CLR开始GC时,会挂起应用程序的所有进程,避免在CLR检查托管堆中的对象时，对象的状态会被改变.
2. CLR把托管堆中的每个对象的同步块索引中的一位设为0.0 表示对象将被回收.
3. CLR遍历活动根,查看哪些引用了堆中的对象.在托管堆中将其标记为1
4. 遍历托管堆,将标记为0的进行垃圾回收
5. 压缩托管堆中的对象
6. 重新确定活动根中引用对象的地址

以上,是不考虑 __代__ 的情况下的GC回收过程.

## 代
考虑到GC对程序性能的影响,也就是不可能每一次都去遍历托管堆中所有的对象,而且在此过程中会Stop the World,所以 CLR引入了代来提升了
GC的效率.
在GC中 代 包含三代,Gen0、Gen1、Gen2,可以理解为这是逻辑上对托管堆的划分,每个代都有自己的预算,当超过这个预算时，即会触发垃圾回收.
如下：  

![](2019_01_05_gc.png)


## GC的触发条件
- 代码显示调用System.GC的静态Collect方法
- Window 报告低内存的情况
- CLR 正在卸载Appdomain
- CLR 正在关闭

## 参考资料
CLR via C# 第四版第二十一章


