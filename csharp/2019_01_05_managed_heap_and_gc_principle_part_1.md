# Managed Heap & CSharp GC Principle (待完善)

本文主要是对《CLR via C#》一书中GC的总结,分上下两篇.

## 目录
- [介绍](#介绍)
- [托管堆内存分配](#托管堆内存分配)
- [GC回收过程](#GC回收过程)
- [代的设计](#代的设计)
- [GC的触发条件](#触发条件)
- [参考资料](#参考资料)

## 介绍
GC(Garbage Collection),主要作用是 __帮助开发者自动管理应用程序内存__.  
了解GC,好处诸多,其中之一就是代码规范,避免出现写出类似下面这种代码:  
``` csharp
            FileStream fs = null;
            StreamWriter sw = null;

            try
            {
                fs = new FileStream(Environment.CurrentDirectory + "/Test.txt", FileMode.OpenOrCreate);
                sw = new StreamWriter(fs);
				//TODO
				//....
            }
            catch (Exception ex)
            {

            }
            finally
            {
                if (sw != null)
                    sw.Dispose();
                if (fs != null)
                    fs.Dispose();
            }
```

## 托管堆内存分配
通常在C#中,我们使用资源需要经过以下流程:  
1. 调用IL指令newobj,为代表资源的类型分配内存
2. 设置资源的初始化状态(通过调用类型的实例构造器来完成).
3. 在实例的生命周期内访问资源(重复).
4. 摧毁资源的状态以进行清理(可选,目前未找到实例验证).
5. 释放内存.

![分配内存](2019_01_05_newobj.png)

从IL上看,分配内存和初始化是一条语句,因此下面将这两个操作合并.
简化之后的流程可以概述为: __分配 & 初始化->使用->释放__

分配的详细流程又可概括为:
1. 计算类型的字段(以及从基类型继承的字段)所需的字节数.
2. 加上实例对象所需要的额外开销(类型对象指针和同步块索引).
3. CLR检查托管堆中是否有足够的空间容纳实例对象所需要的字节数，若有，则分配，反之，则触发GC进行回收

如下图:我们可以发现fs对象中的字占用了228个字节.
![分配内存](2019_01_05_fs.png)

如果仔细验证分配规则,如下:
``` csharp
    public class TestA
    {
        public int id;
        public string Name;

        public TestA(int ID, string Name)
        {
            this.id = ID;
            this.Name = Name;
        }
    }
    public class GCTest_1
    {

        static void Main(string[] args)
        {
            TestA a = new TestA(1, "zh");
        }
    }
```
![分配内存](2019_01_05_testa.png)

如上,*.cs使用的是unicode编码,所以在这里一个字母是2个字节,所以CLR为对象a分配了总共8个字节的内存空间,加上同步块索引和类型对象指针，正好16字节.
因此,验证了书中在托管堆中内存分配的规则.

## GC回收过程
因托管堆的内存不是无限的,所以需要GC释放内存来使程序可以使用更多的资源.在GC进行释放内存时，需要确定哪些资源是需要被释放的，
由此引入引用跟踪算法.过程如下:  
1. CLR开始GC时,会挂起应用程序的所有进程,避免在CLR检查托管堆中的对象时，对象的状态会被改变.
2. CLR把托管堆中的每个对象的同步块索引中的一位设为0.0 表示对象将被回收.
3. CLR遍历活动根,查看哪些引用了堆中的对象.在托管堆中将其标记为1
4. 遍历托管堆,将标记为0的进行垃圾回收
5. 压缩托管堆中的对象
6. 重新确定活动根中引用对象的地址

以上,是不考虑 __代__ 的情况下的GC回收过程.

## 代的设计
考虑到GC对程序性能的影响,也就是不可能每一次都去遍历托管堆中所有的对象,而且在此过程中会Stop the World,所以 CLR引入了代来提升了
GC的效率.  
在GC中 代 包含三代,Gen0、Gen1、Gen2,可以理解为这是逻辑上对托管堆的划分,每个代都有自己的预算,当超过这个预算时，即会触发垃圾回收.
如下：  

![](2019_01_05_gc.png)

CLR在初始化的时候,会为每一代都设定一个预算大小,然而这个大小可以通过GC自己来调节.预算大小是根据每次GC之后幸存的对象的数目来确定的.
每次幸存者数目多，则扩大预算,反之,则缩小代的预算.


## GC的触发条件
- 代码显示调用System.GC的静态Collect方法
- Window 报告低内存的情况
- CLR 正在卸载Appdomain
- CLR 正在关闭

## 参考资料
CLR via C# 第四版第二十一章


